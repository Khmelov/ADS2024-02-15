package by.it.group351001.ushakou.lesson09;

// Импортируем необходимые классы
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

// Класс ListA является частичной реализацией интерфейса List,
// которая имитирует поведение стандартного списка ArrayList.
// Основная цель — реализовать методы управления списком без использования
// стандартных коллекций Java.

// Чтобы реализовать класс ListA, который будет частично или полностью
// имитировать функциональность стандартного класса ArrayList,
// необходимо выполнить следующие шаги:

// Задача:
// 1. Реализовать основные методы интерфейса List:
// - add(E e) — добавление элемента в конец списка.
// - remove(int index) — удаление элемента по индексу.
// - size() — возвращает текущее количество элементов.
// - toString() — вывод элементов списка в виде строки.

// 2. Опциональная реализация методов (в зависимости от требований):
// - Методы управления списком, такие как add(int index, E element)
//   (добавление по индексу), remove(Object o) (удаление по объекту),
//   clear() (очистка списка).
// - Методы поиска: indexOf(Object o) и lastIndexOf(Object o)
//   (поиск индекса первого и последнего вхождения элемента),
//   contains(Object o) (проверка наличия элемента).
// - Методы преобразования списка в массив: toArray(), toArray(T[] a).
// - Методы работы с коллекциями: containsAll(Collection<?> c),
//   addAll(Collection<? extends E> c), removeAll(Collection<?> c),
//   retainAll(Collection<?> c) (работа с несколькими элементами одновременно).
// - Методы итерации: iterator(), listIterator().

// Основные моменты:
// - Увеличение массива при переполнении. При добавлении элементов в список,
//   если массив заполнен, необходимо динамически расширять его
//   (обычно удваивая размер).
// - Удаление элементов. При удалении элемента нужно не только вернуть удалённый
//   объект, но и сдвинуть оставшиеся элементы влево, чтобы избежать "дыр" в массиве.
// - Поиск элементов. Метод indexOf() должен искать первый индекс элемента,
//   а lastIndexOf() — последний. Для этого нужно пройтись по массиву
//   и сравнивать объекты методом equals().

// Структура класса:
// - Класс ListA должен быть параметризован типом E, как и любой стандартный класс коллекций.
// - Для хранения элементов внутри класса используется массив объектов (Object[]),
//   который будет приводиться к типу E[].
// - При необходимости расширять массив, копируя элементы из старого массива в новый.

// Пример реализации методов:
// - Метод add(E e):
//   - Если массив заполнен, создать новый массив большего размера.
//   - Добавить новый элемент и увеличить счётчик элементов.

// - Метод remove(int index):
//   - Проверить, что индекс находится в допустимых пределах.
//   - Удалить элемент, сдвинуть элементы после удалённого влево,
//     чтобы заполнить "пустоту".
//   - Вернуть удалённый элемент.

// Что уже реализовано:
// - Основные методы, такие как add(E e), remove(int index), toString()
//   и другие базовые методы списка, уже реализованы в примере.
// - Оставшиеся методы помечены как "TODO", и их реализация остаётся на ваше усмотрение
//   в зависимости от потребностей проекта.

// Что нужно доделать:
// 1. Реализовать все необязательные методы, если они необходимы для тестов
//    или других задач.
// 2. Протестировать класс, чтобы убедиться в корректной работе основных операций
//    (добавление, удаление, поиск и т.д.).

// Таким образом, после завершения всех этих шагов класс ListA будет готов к использованию
// как кастомная реализация списка с динамическим увеличением массива
// и базовыми операциями работы с элементами.

// Объявляем класс ListA, который реализует интерфейс List
public class ListA<E> implements List<E> {

    // Стандартный размер массива
    static final int defSize = 8;
    // Массив для хранения элементов списка
    E[] _list;
    // Текущий индекс для отслеживания количества элементов
    int _curItem = 0;

    // Конструктор по умолчанию, инициализирует массив стандартным размером
    public ListA() {
        this(defSize); // Вызов конструктора с аргументом, чтобы задать дефолтный размер
    }

    // Конструктор, который позволяет задать размер массива
    public ListA(int size) {
        // Инициализация массива с указанным размером
        _list = (E[]) new Object[size]; // Приведение массива к типу E
    }

    // Переопределение метода toString для отображения содержимого списка
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        // Проходим по массиву и добавляем элементы в строку
        for (int i = 0; i < _curItem; ++i) {
            E curSym = _list[i]; // Текущий элемент
            sb.append(curSym); // Добавляем в строку
            // Добавляем запятую, если это не последний элемент
            if (i < _curItem - 1) {
                sb.append(", ");
            }
        }
        sb.append("]"); // Закрываем строку
        return sb.toString(); // Возвращаем результат
    }

    // Метод добавления элемента в конец списка
    @Override
    public boolean add(E e) {
        // Если текущий индекс превышает длину массива, увеличиваем размер массива
        if (_curItem >= _list.length) {
            E[] _cList = (E[]) new Object[_list.length * 2]; // Увеличиваем размер массива вдвое
            // Копируем старые элементы в новый массив
            for (int i = 0; i < _list.length; ++i) {
                _cList[i] = _list[i]; // Копируем элементы
            }
            _list = _cList; // Обновляем ссылку на новый массив
        }
        _list[_curItem] = e; // Добавляем новый элемент на текущее свободное место
        _curItem++; // Увеличиваем текущее количество элементов
        return true; // Возвращаем true, указывая на успешное добавление
    }

    // Метод удаления элемента по индексу
    @Override
    public E remove(int index) {
        // Проверка на корректность индекса
        if (index < 0 || index >= _curItem) {
            return null; // Если индекс некорректный, возвращаем null
        }

        E _rItem = _list[index]; // Сохраняем удаляемый элемент

        // Сдвигаем элементы влево, чтобы заполнить пустое место
        for (int i = index; i < _curItem - 1; ++i) {
            _list[i] = _list[i + 1]; // Перемещаем элементы влево
        }

        _curItem--; // Уменьшаем текущее количество элементов
        return _rItem; // Возвращаем удалённый элемент
    }

    // Метод для получения текущего количества элементов в списке
    @Override
    public int size() {
        return _curItem; // Возвращаем текущее количество элементов
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    //////               Опциональные к реализации методы             ///////
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////

    // Метод добавления элемента по индексу (не реализован)
    @Override
    public void add(int index, E element) {
        // TODO: Реализация метода
    }

    // Метод удаления элемента по объекту (не реализован)
    @Override
    public boolean remove(Object o) {
        // TODO: Реализация метода
        return false;
    }

    // Метод замены элемента по индексу (не реализован)
    @Override
    public E set(int index, E element) {
        // TODO: Реализация метода
        return null;
    }

    // Метод проверки, является ли список пустым
    @Override
    public boolean isEmpty() {
        return _curItem == 0; // Если количество элементов равно 0, то список пуст
    }

    // Метод очистки списка
    @Override
    public void clear() {
        _list = (E[]) new Object[defSize]; // Инициализация массива заново
        _curItem = 0; // Сбрасываем количество элементов
    }

    // Метод поиска индекса объекта
    @Override
    public int indexOf(Object o) {
        // Проходим по списку и ищем совпадение
        for (int i = 0; i < _curItem; i++) {
            if (_list[i].equals(o)) {
                return i; // Возвращаем индекс, если нашли
            }
        }
        return -1; // Если не найден, возвращаем -1
    }

    // Метод получения элемента по индексу
    @Override
    public E get(int index) {
        // Проверка на корректность индекса
        if (index >= 0 && index < _curItem) {
            return _list[index]; // Возвращаем элемент
        }
        return null; // Если индекс некорректный, возвращаем null
    }

    // Метод проверки наличия объекта в списке
    @Override
    public boolean contains(Object o) {
        return indexOf(o) >= 0; // Проверяем, есть ли объект в списке
    }

    // Метод получения последнего индекса объекта
    @Override
    public int lastIndexOf(Object o) {
        // Ищем с конца списка
        for (int i = _curItem - 1; i >= 0; i--) {
            if (_list[i].equals(o)) {
                return i; // Возвращаем последний индекс, если нашли
            }
        }
        return -1; // Если не найден, возвращаем -1
    }

    // Метод проверки наличия всех объектов из коллекции (не реализован)
    @Override
    public boolean containsAll(Collection<?> c) {
        // TODO: Реализация метода
        return false;
    }

    // Метод добавления всех объектов из коллекции (не реализован)
    @Override
    public boolean addAll(Collection<? extends E> c) {
        // TODO: Реализация метода
        return false;
    }

    // Метод добавления всех объектов из коллекции по индексу (не реализован)
    @Override
    public boolean addAll(int index, Collection<? extends E> c) {
        // TODO: Реализация метода
        return false;
    }

    // Метод удаления всех объектов из коллекции (не реализован)
    @Override
    public boolean removeAll(Collection<?> c) {
        // TODO: Реализация метода
        return false;
    }

    // Метод сохранения только объектов из коллекции (не реализован)
    @Override
    public boolean retainAll(Collection<?> c) {
        // TODO: Реализация метода
        return false;
    }

    // Метод получения подсписка (не реализован)
    @Override
    public List<E> subList(int fromIndex, int toIndex) {
        // TODO: Реализация метода
        return null;
    }

    // Метод получения итератора с указанного индекса (не реализован)
    @Override
    public ListIterator<E> listIterator(int index) {
        // TODO: Реализация метода
        return null;
    }

    // Метод получения итератора (не реализован)
    @Override
    public ListIterator<E> listIterator() {
        // TODO: Реализация метода
        return null;
    }

    // Метод преобразования списка в массив (не реализован)
    @Override
    public <T> T[] toArray(T[] a) {
        // TODO: Реализация метода
        return null;
    }

    // Метод преобразования списка в массив
    @Override
    public Object[] toArray() {
        Object[] result = new Object[_curItem]; // Создаём новый массив
        for (int i = 0; i < _curItem; i++) {
            result[i] = _list[i]; // Копируем элементы
        }
        return result; // Возвращаем массив
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    ////////        Эти методы имплементировать необязательно    ////////////
    ////////        но они будут нужны для корректной отладки    ////////////
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    // Метод получения итератора (не реализован)
    @Override
    public Iterator<E> iterator() {
        // TODO: Реализация метода
        return null;
    }
}
